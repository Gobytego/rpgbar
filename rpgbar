#!/bin/bash

# ====================================================================
# RPG BAR: Persistent HUD for Bash Terminal
# ====================================================================

# --- Configuration & Initialization ---

RPG_SAVE_FILE="$HOME/.rpgbar.save"

# Variables to hold calculated stats
RPG_LEVEL=1
RPG_XP=0
RPG_XP_TO_NEXT_LEVEL=5
RPG_HP=100
RPG_STAMINA=100
RPG_MP=100
RPG_GOLD=0
LAST_GOLD_TIME=0
CAN_DISPLAY_EMOJI=0 
USE_ASCII_BORDERS=0 

# --- THEME/COLOR VARIABLES ---
# Using tput for maximum compatibility where possible, falling back to ANSI
# We store the raw integer for tput setab (Set Background) if possible, or the ANSI string.
CURRENT_BG_CODE="$(tput setab 0)" # Default Black
BG_BLACK="$(tput setab 0)"
BG_RED="$(tput setab 1)"
BG_GREEN="$(tput setab 2)"
BG_YELLOW="$(tput setab 3)"
BG_DARK_BLUE="$(tput setab 4)"
BG_MAGENTA="$(tput setab 5)"
BG_CYAN="$(tput setab 6)"
BG_WHITE="$(tput setab 7)"
# Gray usually requires high intensity or specific ANSI, sticking to ANSI for gray
BG_GRAY="\033[100m"

RESET="\033[0m"
BOLD="\033[1m"
COLOR_BORDER="\033[33;1m" # Bright Yellow

# Emojis
EMOJI_HP="‚ù§Ô∏è"
EMOJI_SP="‚ö°"
EMOJI_MP="üîÆ"
EMOJI_GOLD="üí∞"
EMOJI_XP="‚ú®"

# Borders
BORDER_UNICODE=("‚ïî" "‚ïê" "‚ïó" "‚ïë" "‚ïö" "‚ïù")
BORDER_ASCII=("+" "=" "+" "|" "+" "+") 

# ====================================================================
# --- FUNCTIONS ---
# ====================================================================

check_emoji_support() {
    # Simple check: if we print a wide char, does cursor move 2 spaces?
    # This is a heuristic.
    echo 1
}

save_stats() {
    cat <<EOF > "$RPG_SAVE_FILE"
RPG_LEVEL=$RPG_LEVEL
RPG_XP=$RPG_XP
RPG_GOLD=$RPG_GOLD
LAST_GOLD_TIME=$LAST_GOLD_TIME
CAN_DISPLAY_EMOJI=$CAN_DISPLAY_EMOJI
USE_ASCII_BORDERS=$USE_ASCII_BORDERS
CURRENT_BG_CODE_NAME="$CURRENT_BG_CODE_NAME"
EOF
}

load_stats() {
    if [ -f "$RPG_SAVE_FILE" ]; then
        source "$RPG_SAVE_FILE" 2>/dev/null
    fi 
    
    # Defaults if file missing or empty
    : ${RPG_LEVEL:=1}
    : ${RPG_XP:=0}
    : ${RPG_GOLD:=0}
    : ${LAST_GOLD_TIME:=$(date +%s)}
    : ${CAN_DISPLAY_EMOJI:=0}
    : ${USE_ASCII_BORDERS:=0}
    : ${CURRENT_BG_CODE_NAME:="Black"}
    
    # Map name back to code
    set_bg_from_name "$CURRENT_BG_CODE_NAME"
    
    RPG_XP_TO_NEXT_LEVEL=$(( 5 * RPG_LEVEL ))
}

set_bg_from_name() {
    case "$1" in
        "Black") CURRENT_BG_CODE="$BG_BLACK" ;;
        "Gray") CURRENT_BG_CODE="$BG_GRAY" ;;
        "Red") CURRENT_BG_CODE="$BG_RED" ;;
        "Green") CURRENT_BG_CODE="$BG_GREEN" ;;
        "Yellow") CURRENT_BG_CODE="$BG_YELLOW" ;;
        "Dark Blue") CURRENT_BG_CODE="$BG_DARK_BLUE" ;;
        "Magenta") CURRENT_BG_CODE="$BG_MAGENTA" ;;
        "Cyan") CURRENT_BG_CODE="$BG_CYAN" ;;
        "White") CURRENT_BG_CODE="$BG_WHITE" ;;
        *) CURRENT_BG_CODE="$BG_BLACK" ;;
    esac
}

get_cpu_usage() { 
    # Linux specific top parsing
    if command -v mpstat &> /dev/null; then
        mpstat 1 1 | awk '/Average:/ {print 100 - $12}' | cut -d. -f1
    else
        top -bn1 | grep "Cpu(s)" | awk '{print $8}' | sed 's/,//' | awk '{print int(100 - $1)}'
    fi
}
get_ram_usage() { free -m | grep Mem | awk '{print int($3/$2 * 100)}'; }
get_swap_usage() { free -m | grep Swap | awk '{ if ($2>0) print int($3/$2 * 100); else print 0;}'; }

update_stats() { 
    local cpu=$(get_cpu_usage)
    local ram=$(get_ram_usage)
    local swap=$(get_swap_usage)
    
    # Sanitize inputs to ensure numbers
    re='^[0-9]+$'
    if ! [[ $cpu =~ $re ]]; then cpu=0; fi
    if ! [[ $ram =~ $re ]]; then ram=0; fi
    if ! [[ $swap =~ $re ]]; then swap=0; fi

    RPG_HP=$(( 100 - ram ))
    RPG_STAMINA=$(( 100 - cpu ))
    RPG_MP=$(( 100 - swap ))
}

grant_xp() {
    local gain=$(( 1 + RANDOM % 3 ))
    RPG_XP=$(( RPG_XP + gain ))
    RPG_XP_TO_NEXT_LEVEL=$(( 5 * RPG_LEVEL ))
    if [ $RPG_XP -ge $RPG_XP_TO_NEXT_LEVEL ]; then
        local remainder=$(( RPG_XP - RPG_XP_TO_NEXT_LEVEL ))
        RPG_LEVEL=$(( RPG_LEVEL + 1 ))
        RPG_XP=$remainder
    fi
}

award_gold() {
    local now=$(date +%s)
    local diff=$(( now - LAST_GOLD_TIME ))
    local interval=1800
    
    if [ "$diff" -ge "$interval" ]; then
        local intervals=$(( diff / interval ))
        local award=$(( (1 + RANDOM % 10) * intervals ))
        RPG_GOLD=$(( RPG_GOLD + award ))
        LAST_GOLD_TIME=$(( LAST_GOLD_TIME + (intervals * interval) ))
    fi
}

repeat_char() {
    local char="$1"
    local count="$2"
    local out=""
    for ((i=0; i<count; i++)); do out="${out}${char}"; done
    printf "%s" "$out"
}

# Revised pad_string: Just returns text + spaces.
pad_string() {
    local str="$1"
    local width="$2"
    local bonus="$3"
    
    # Strip ANSI codes to measure length
    local clean_str=$(echo -e "$str" | sed 's/\x1b\[[0-9;]*m//g')
    local len=${#clean_str}
    
    # Adjust for emojis if needed
    local real_width=$(( len + bonus ))
    local pad_len=$(( width - real_width ))
    
    if [ $pad_len -lt 0 ]; then pad_len=0; fi
    
    local padding=""
    for ((i=0; i<pad_len; i++)); do padding="${padding} "; done
    
    # Return string + padding (spaces will inherit BG color when printed later)
    printf "%b%s" "$str" "$padding"
}

draw_rpg_hud() {
    load_stats
    update_stats; grant_xp; award_gold; save_stats
    
    # Set borders
    local C_TL C_H C_TR C_V C_BL C_BR
    if [ "$USE_ASCII_BORDERS" -eq 1 ]; then
        C_TL="${BORDER_ASCII[0]}"; C_H="${BORDER_ASCII[1]}"; C_TR="${BORDER_ASCII[2]}"
        C_V="${BORDER_ASCII[3]}"; C_BL="${BORDER_ASCII[4]}"; C_BR="${BORDER_ASCII[5]}"
    else
        C_TL="${BORDER_UNICODE[0]}"; C_H="${BORDER_UNICODE[1]}"; C_TR="${BORDER_UNICODE[2]}"
        C_V="${BORDER_UNICODE[3]}"; C_BL="${BORDER_UNICODE[4]}"; C_BR="${BORDER_UNICODE[5]}"
    fi

    local width=77
    local line_h=$(repeat_char "$C_H" $width)
    
    # Prepare Content strings 
    
    # Use $HOSTNAME first, then explicitly run `hostname`
    local current_host="${HOSTNAME:-$(hostname)}"
    
    local raw_loc=$(pwd)
    if [ ${#raw_loc} -gt 30 ]; then
        raw_loc="...${raw_loc: -27}"
    fi
    
    # Use the reliable current_host variable
    local name_line=" \033[39mHero: \033[36m$USER\033[39m | World: \033[36m$current_host\033[39m | Location: \033[35m$raw_loc\033[39m "
    
    local stat_line=""
    local bonus=0
    if [ "$CAN_DISPLAY_EMOJI" -eq 1 ]; then
        bonus=3
        stat_line=" \033[39mLVL: \033[33m$RPG_LEVEL\033[39m | ${EMOJI_HP} HP: \033[31m$RPG_HP%\033[39m | ${EMOJI_SP}SP: \033[34m$RPG_STAMINA%\033[39m | ${EMOJI_MP}MP: \033[35m$RPG_MP%\033[39m | ${EMOJI_GOLD}\033[33m$RPG_GOLD G\033[39m | ${EMOJI_XP}XP: \033[32m$RPG_XP/$RPG_XP_TO_NEXT_LEVEL\033[39m "
    else
        stat_line=" \033[39mLVL: \033[33m$RPG_LEVEL\033[39m | HP: \033[31m$RPG_HP%\033[39m | SP: \033[34m$RPG_STAMINA%\033[39m | MP: \033[35m$RPG_MP%\033[39m | \033[33m$RPG_GOLD G\033[39m | XP: \033[32m$RPG_XP/$RPG_XP_TO_NEXT_LEVEL\033[39m "
    fi

    # Pad content
    local content1=$(pad_string "$name_line" $width 0)
    local content2=$(pad_string "$stat_line" $width $bonus)

    # --- DRAWING ---
    tput sc; tput cup 0 0
    
    # 1. Top Border
    printf "\033[0m\033[K%b%b%s%s%b\033[0m\n" "$CURRENT_BG_CODE" "$COLOR_BORDER" "$C_TL" "$line_h" "$C_TR"
    
    # 2. Line 1
    printf "\033[0m\033[K%b%b%s\033[0m%b%s%b%b%s\033[0m\n" "$CURRENT_BG_CODE" "$COLOR_BORDER" "$C_V" "$CURRENT_BG_CODE" "$content1" "$CURRENT_BG_CODE" "$COLOR_BORDER" "$C_V"
    
    # 3. Line 2
    printf "\033[0m\033[K%b%b%s\033[0m%b%s%b%b%s\033[0m\n" "$CURRENT_BG_CODE" "$COLOR_BORDER" "$C_V" "$CURRENT_BG_CODE" "$content2" "$CURRENT_BG_CODE" "$COLOR_BORDER" "$C_V"
    
    # 4. Bottom Border
    printf "\033[0m\033[K%b%b%s%s%b\033[0m" "$CURRENT_BG_CODE" "$COLOR_BORDER" "$C_BL" "$line_h" "$C_BR"

    # 5. Reset for Prompt
    tput cup 4 0
    printf "\033[0m\033[K" # Hard reset and clear prompt line
    tput rc
}

rpg_color_menu() {
    local options=("Black" "Gray" "Red" "Green" "Yellow" "Dark Blue" "Magenta" "Cyan" "White")
    
    while true; do
        load_stats
        echo -e "\n\033[1m--- Background Theme ---\033[0m"
        echo -e "Current: $CURRENT_BG_CODE_NAME"
        echo "------------------------"
        for i in "${!options[@]}"; do
            echo "[$((i+1))] ${options[$i]}"
        done
        echo "[Q] Back"
        read -r -p "Select: " sel
        
        if [[ "$sel" =~ ^[0-9]+$ ]] && [ "$sel" -ge 1 ] && [ "$sel" -le 9 ]; then
            CURRENT_BG_CODE_NAME="${options[$((sel-1))]}"
            save_stats
            echo -e "\033[32mTheme set to $CURRENT_BG_CODE_NAME\033[0m"
        elif [[ "$sel" =~ [Qq] ]]; then
            return 0
        fi
    done
}

rpg_settings_menu() {
    while true; do
        load_stats
        echo -e "\n\033[1m--- RPG Settings ---\033[0m"
        echo "[1] Toggle Emojis (Current: $CAN_DISPLAY_EMOJI)"
        echo "[2] Toggle ASCII (Current: $USE_ASCII_BORDERS)"
        echo "[3] Change Theme"
        echo "[Q] Exit"
        read -r -p "Opt: " opt
        case "$opt" in
            1) CAN_DISPLAY_EMOJI=$((1-CAN_DISPLAY_EMOJI)); save_stats ;;
            2) USE_ASCII_BORDERS=$((1-USE_ASCII_BORDERS)); save_stats ;;
            3) rpg_color_menu ;;
            [Qq]) return 0 ;;
        esac
    done
}

rpg_check() {
    echo "Checking dependencies..."
    for cmd in tput bc grep awk sed; do
        if command -v $cmd &>/dev/null; then echo "$cmd: OK"; else echo "$cmd: MISSING"; fi
    done
}

rpg_reset() {
    rm -f "$RPG_SAVE_FILE"
    echo "Stats reset."
}

rpgbar_main() {
    # If arguments are passed, handle them
    if [ -n "$1" ]; then
        case "$1" in
            --check) rpg_check ;;
            --reset) rpg_reset ;;
            --settings) rpg_settings_menu ;;
            --help) echo "Usage: source rpgbar OR rpgbar --settings" ;;
        esac
    else
        # If no arguments, assume we are setting up the prompt
        load_stats
        PROMPT_COMMAND="draw_rpg_hud"
    fi
}

# Execution Logic
# If run directly (executable) OR sourced with arguments
if [[ "${BASH_SOURCE[0]}" == "$0" ]] || [[ -n "$1" ]]; then
    rpgbar_main "$@"
fi

# If sourced (interactive shell setup) without arguments
if [[ "${BASH_SOURCE[0]}" != "$0" ]] && [[ -z "$1" ]]; then
    rpgbar_main
fi
